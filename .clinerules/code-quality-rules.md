# Cline コード品質ルール

## コードスタイル

### 命名規則

#### 共通ルール
- 意味のある名前を使用する
- 略語は一般的に認知されているもの以外は避ける
- 単語の区切りには一貫した方法を使用する

#### JavaScript/TypeScript
- 変数・関数: キャメルケース (`myVariable`, `calculateTotal`)
- クラス・インターフェース: パスカルケース (`UserService`, `DataProvider`)
- 定数: 大文字のスネークケース (`MAX_RETRY_COUNT`, `API_BASE_URL`)
- プライベートメンバー: アンダースコア接頭辞 (`_privateVariable`)
- 型パラメータ: 単一の大文字または説明的なパスカルケース (`T`, `TKey`, `TValue`, `ResponseType`)
- ブール値を表す変数: `is`, `has`, `can` などの接頭辞 (`isValid`, `hasPermission`)

#### CSS/SCSS
- クラス名: ケバブケース (`header-container`, `nav-item`)
- BEM 命名規則の採用
  - ブロック: `.block`
  - 要素: `.block__element`
  - モディファイア: `.block--modifier`, `.block__element--modifier`

#### ファイル名
- コンポーネント: パスカルケース (`UserProfile.tsx`, `DataTable.tsx`)
- ユーティリティ/サービス: キャメルケース (`apiService.ts`, `dateUtils.ts`)
- テスト: 対象ファイル名 + `.test` または `.spec` (`apiService.test.ts`)

### フォーマット

#### インデント
- 2スペースを使用
- タブ文字は使用しない
- switch-case 文ではケースをインデント

#### 行の長さ
- 最大100文字
- 長い行は適切に改行

#### 空白と改行
- 演算子の前後に空白を入れる
- カンマの後に空白を入れる
- 関数やブロックの間に空行を入れる
- 論理的なコードブロックの間に空行を入れる
- 行末の空白は削除

#### 括弧とブレース
- 制御構文の括弧は同じ行に配置 (`if (condition) {`)
- 関数宣言の括弧は同じ行に配置 (`function name() {`)
- 複数行のブロックは常に中括弧を使用

### コメント

#### ドキュメンテーションコメント
- 公開 API、クラス、関数には JSDoc/TSDoc コメントを使用
- パラメータ、戻り値、例外をドキュメント化
- 複雑なアルゴリズムには概要説明を追加

```typescript
/**
 * ユーザーを認証し、JWTトークンを返す
 * @param username ユーザー名
 * @param password パスワード
 * @returns JWT認証トークン
 * @throws {AuthError} 認証に失敗した場合
 */
function authenticate(username: string, password: string): string {
  // 実装
}
```

#### インラインコメント
- 複雑なロジックや非明示的な意図の説明に使用
- 「なぜ」に焦点を当てる（「何を」はコード自体が説明すべき）
- TODO, FIXME, NOTE などのマーカーを適切に使用

## コード構造

### ファイル構成
- 1ファイルにつき1つの主要な概念（クラス、コンポーネント、機能）
- ファイルサイズは300行以内を目標に
- 関連するファイルは同じディレクトリに配置
- 論理的なディレクトリ構造を維持

### 関数/メソッド
- 単一責任の原則に従う
- 関数は30行以内を目標に
- 引数は3つ以下が理想
- 複雑な引数セットはオブジェクトにまとめる
- 早期リターンを活用して入れ子を減らす

### クラス/コンポーネント
- 単一責任の原則に従う
- 継承よりコンポジションを優先
- メソッドの論理的なグループ化
- プライベートメソッドとパブリックメソッドを明確に分離

## コード品質

### エラー処理
- 例外は適切にキャッチして処理
- カスタム例外クラスを活用
- エラーメッセージは具体的かつ有用に
- ユーザー向けエラーと開発者向けエラーを区別

### 非同期処理
- Promise チェーンよりも async/await を優先
- エラーハンドリングを忘れない（try-catch または .catch()）
- 並列処理が可能な場合は Promise.all を活用
- 非同期関数は名前に Async サフィックスを付けることを検討

### パフォーマンス
- 不必要なレンダリングを避ける
- メモ化を適切に活用
- 大きなループ処理は最適化
- リソースの適切な解放（イベントリスナー、サブスクリプションなど）

### セキュリティ
- ユーザー入力は常にバリデーションとサニタイズ
- SQL インジェクションやXSSを防止
- 機密情報をクライアントサイドに保存しない
- HTTPS 通信の使用
- CSRF 対策の実装

## テスト

### ユニットテスト
- 各関数/メソッドの主要なパスをカバー
- 境界条件のテスト
- モックとスタブを適切に活用
- テストは独立して実行可能に

### 統合テスト
- コンポーネント間の相互作用をテスト
- 主要なユースケースをカバー
- 実際の依存関係を使用（可能な場合）

### E2Eテスト
- 重要なユーザーフローをカバー
- 実際の環境に近い条件でテスト
- フラキーテストを避けるための安定性対策

### テストの品質
- テストコードもプロダクションコードと同じ品質基準を適用
- テストの意図が明確になるような命名
- 各テストは単一の概念をテスト
- 適切なアサーションメッセージ

## ツールと自動化

### リンター
- ESLint/TSLint を使用
- プロジェクト固有のルールセットを定義
- コミット前にリントエラーを修正

### フォーマッター
- Prettier を使用
- 一貫したフォーマットルールを適用
- エディタ設定と連携

### 型チェック
- TypeScript の厳格モードを有効化
- any 型の使用を最小限に
- 型定義ファイルの適切な管理

### 依存関係管理
- 依存関係は明示的にバージョン指定
- 定期的な更新とセキュリティチェック
- 未使用の依存関係を削除
