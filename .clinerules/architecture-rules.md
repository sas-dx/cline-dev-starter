# Cline アーキテクチャルール

## 全体アーキテクチャ

### レイヤードアーキテクチャ

アプリケーションは以下の層に分けて構築します：

1. **プレゼンテーション層**
   - ユーザーインターフェース
   - ユーザー入力の処理
   - データの表示

2. **アプリケーション層**
   - ユースケースの実装
   - ビジネスロジックの調整
   - トランザクション管理

3. **ドメイン層**
   - ビジネスルールとロジック
   - エンティティと値オブジェクト
   - ドメインサービス

4. **インフラストラクチャ層**
   - 外部システムとの連携
   - データベースアクセス
   - API クライアント
   - ファイルシステム操作

### 依存関係の方向

- 内側の層は外側の層に依存してはならない
- 依存関係は常に外側から内側へ向かう
- 外側の層から内側の層への依存は抽象（インターフェース）を通じて行う

```
プレゼンテーション層 → アプリケーション層 → ドメイン層 ← インフラストラクチャ層
```

## フロントエンドアーキテクチャ

### コンポーネント設計

#### アトミックデザイン
コンポーネントを以下の5つのレベルに分類：

1. **原子 (Atoms)**
   - ボタン、入力フィールド、ラベルなどの最小単位のコンポーネント
   - 他のコンポーネントに依存しない

2. **分子 (Molecules)**
   - 複数の原子を組み合わせた機能単位
   - 例：検索フォーム（入力フィールドとボタンの組み合わせ）

3. **有機体 (Organisms)**
   - 分子と原子を組み合わせた複雑なコンポーネント
   - 例：ヘッダー、フォーム、商品カードリストなど

4. **テンプレート (Templates)**
   - ページのレイアウト構造を定義
   - 実際のコンテンツではなく、コンポーネントの配置を示す

5. **ページ (Pages)**
   - テンプレートにデータを流し込んだ実際のページ
   - ルーティングの対象となる

#### コンポーネントの責務分離

- **表示コンポーネント (Presentational Components)**
  - 見た目に関する責務のみを持つ
  - プロップスを通じてデータを受け取り表示
  - 状態を持たない（または UI 状態のみ）
  - 再利用性が高い

- **コンテナコンポーネント (Container Components)**
  - データの取得や状態管理を担当
  - 表示コンポーネントにデータを渡す
  - ビジネスロジックを含む
  - 再利用性は低い

### 状態管理

#### グローバル状態
- アプリケーション全体で共有される状態
- 認証情報、テーマ設定、グローバル通知など
- Redux, MobX, Context API などを使用

#### ローカル状態
- 特定のコンポーネントやページに閉じた状態
- フォームの入力値、UI の開閉状態など
- React の useState, useReducer などを使用

#### 状態管理の原則
- 状態は必要最小限に保つ
- 導出可能なデータは状態として持たない
- 状態の更新は予測可能な方法で行う
- 副作用は分離する

### ルーティング
- ネストされたルーティング構造
- コード分割によるルートベースの遅延ロード
- ルートパラメータとクエリパラメータの適切な使い分け
- ルートガードによる認証・認可の制御

## バックエンドアーキテクチャ

### API 設計

#### RESTful API 原則
- リソース指向の URL 設計
- 適切な HTTP メソッドの使用
- ステートレスな通信
- HATEOAS（Hypermedia as the Engine of Application State）の考慮

#### エンドポイント命名規則
- 名詞を使用し、複数形を基本とする
- `/api/v1/users`, `/api/v1/products` など
- 階層関係は `/api/v1/users/{id}/orders` のように表現
- 動詞は避け、HTTP メソッドで操作を表現

#### レスポンス形式
- 一貫した JSON 構造
- エラーレスポンスの標準化
- ページネーション情報の含め方
- バージョニング戦略

### データアクセス

#### リポジトリパターン
- データアクセスロジックをドメインロジックから分離
- インターフェースを通じた実装の抽象化
- テスト容易性の向上

#### O/R マッピング
- エンティティとデータベーステーブルのマッピング
- リレーションシップの適切な設計
- 遅延ロードと即時ロードの使い分け

#### クエリ最適化
- N+1 問題の回避
- インデックスの適切な設計
- 必要なデータのみを取得

### ビジネスロジック

#### ドメインサービス
- エンティティ単体では表現できないビジネスロジック
- 複数のエンティティにまたがる操作
- トランザクション境界の明確化

#### アプリケーションサービス
- ユースケースの実装
- トランザクション管理
- 認可チェック
- イベント発行

#### CQRS パターン（必要に応じて）
- コマンド（書き込み）とクエリ（読み取り）の責務分離
- 異なるモデルとデータストアの使用
- スケーラビリティと性能の向上

## クロスカッティングコンサーン

### ロギング
- 構造化ログの採用
- ログレベルの適切な使い分け
- コンテキスト情報の付加
- パフォーマンスへの配慮

### エラーハンドリング
- 例外の適切な粒度と種類
- グローバルエラーハンドラの実装
- エラーの適切な伝播
- ユーザーフレンドリーなエラーメッセージ

### 認証と認可
- JWT または OAuth 2.0 ベースの認証
- ロールベースのアクセス制御
- 認可チェックの一貫した実装
- セッション管理とトークン更新戦略

### キャッシュ戦略
- 複数レイヤーでのキャッシュ
- キャッシュの無効化ポリシー
- 分散キャッシュの考慮
- キャッシュヒット率の監視

## マイクロサービスアーキテクチャ（該当する場合）

### サービス境界
- ドメイン駆動設計の境界付けられたコンテキストに基づく分割
- サービス間の依存関係の最小化
- 適切な粒度の決定

### サービス間通信
- 同期通信（REST, gRPC）と非同期通信（メッセージキュー）の使い分け
- API ゲートウェイの役割
- サーキットブレーカーパターンの適用

### データ管理
- データベース分離（サービスごとに独立したデータベース）
- 分散トランザクション対策
- イベントソーシングとCQRSの検討

### デプロイと運用
- コンテナ化とオーケストレーション
- CI/CD パイプラインの自動化
- 監視とアラート
- カナリアリリースとブルー/グリーンデプロイ

## セキュリティアーキテクチャ

### 認証メカニズム
- 多要素認証の実装
- パスワードハッシュ化と保存
- セッション管理とトークン更新戦略

### データ保護
- 転送中のデータの暗号化（TLS/SSL）
- 保存データの暗号化
- 機密情報の適切な取り扱い

### 入力検証
- すべてのユーザー入力の検証
- サーバーサイドでの再検証
- SQLインジェクション対策
- XSS対策

### アクセス制御
- 最小権限の原則
- ロールベースアクセス制御（RBAC）
- 属性ベースアクセス制御（ABAC）
- API レベルでの認可チェック

## パフォーマンスとスケーラビリティ

### パフォーマンス最適化
- レンダリングパフォーマンス
- ネットワークリクエストの最適化
- データベースクエリの最適化
- キャッシュ戦略

### スケーラビリティ設計
- 水平スケーリングを考慮した設計
- ステートレスなサービス
- 負荷分散戦略
- データベースのシャーディングと複製

### 監視と計測
- パフォーマンスメトリクスの収集
- ユーザー体験の計測
- ボトルネックの特定
- 継続的な最適化
